import socket
import threading
import tkinter as tk
from tkinter import scrolledtext, messagebox
import datetime

class LocalMessenger:
    def __init__(self):
        self.host = self.get_local_ip()
        self.port = 12345
        self.clients = {}
        self.groups = {
            "Общий чат": set(),
            "Работа": set(),
            "Разное": set()
        }
        
        self.setup_gui()
        self.start_server()
        
    def get_local_ip(self):
        """Получает локальный IP адрес"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
    
    def start_server(self):
        """Запускает сервер для приема сообщений"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            self.server_socket.bind((self.host, self.port))
            self.add_message(f"Сервер запущен на {self.host}:{self.port}", "system")
        except:
            self.host = "127.0.0.1"
            self.server_socket.bind((self.host, self.port))
            self.add_message(f"Сервер запущен на {self.host}:{self.port}", "system")
        
        # Поток для приема сообщений
        receive_thread = threading.Thread(target=self.receive_messages)
        receive_thread.daemon = True
        receive_thread.start()
        
        # Поток для поиска других пользователей
        discovery_thread = threading.Thread(target=self.discover_users)
        discovery_thread.daemon = True
        discovery_thread.start()
    
    def discover_users(self):
        """Обнаружение других пользователей в сети"""
        discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        discovery_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        
        # Отправка broadcast сообщения
        message = f"DISCOVERY:{self.host}"
        
        while True:
            try:
                discovery_socket.sendto(message.encode('utf-8'), ('255.255.255.255', 12346))
                threading.Event().wait(5)  # Ждем 5 секунд
            except:
                pass
    
    def receive_messages(self):
        """Прием сообщений от других пользователей"""
        while True:
            try:
                data, addr = self.server_socket.recvfrom(1024)
                message = data.decode('utf-8')
                self.process_message(message, addr)
            except Exception as e:
                self.add_message(f"Ошибка приема: {str(e)}", "error")
    
    def process_message(self, message, addr):
        """Обработка входящих сообщений"""
        if message.startswith("DISCOVERY:"):
            # Обнаружен новый пользователь
            user_ip = message.split(":")[1]
            if user_ip != self.host and user_ip not in self.clients:
                self.clients[user_ip] = addr
                self.update_users_list()
                self.add_message(f"Обнаружен пользователь: {user_ip}", "system")
        elif message.startswith("PRIVATE:"):
            # Личное сообщение
            parts = message.split(":", 2)
            if len(parts) == 3:
                sender, recipient, content = parts
                if recipient == self.host:
                    self.add_message(f"[Лично от {sender}] {content}", "private")
        elif message.startswith("GROUP:"):
            # Групповое сообщение
            parts = message.split(":", 2)
            if len(parts) == 3:
                group, sender, content = parts
                self.add_message(f"[{group} от {sender}] {content}", "group")
        else:
            # Обычное сообщение
            self.add_message(f"[{addr[0]}] {message}", "normal")
    
    def send_message(self, message=None):
        """Отправка сообщения"""
        if message is None:
            message = self.message_entry.get()
            if not message.strip():
                return
        
        # Определяем тип сообщения
        current_tab = self.get_current_tab()
        
        if current_tab.startswith("Лично:"):
            # Личное сообщение
            recipient = current_tab.split(":")[1]
            full_message = f"PRIVATE:{self.host}:{recipient}:{message}"
            self.send_to_user(recipient, full_message)
            self.add_message(f"[Я → {recipient}] {message}", "my_private")
        elif current_tab in self.groups:
            # Групповое сообщение
            full_message = f"GROUP:{current_tab}:{self.host}:{message}"
            self.broadcast_to_group(current_tab, full_message)
            self.add_message(f"[{current_tab}] Я: {message}", "my_group")
        else:
            # Общее сообщение всем
            self.broadcast_message(message)
            self.add_message(f"Я: {message}", "my_normal")
        
        if message is not None:
            self.message_entry.delete(0, tk.END)
    
    def send_to_user(self, user_ip, message):
        """Отправка сообщения конкретному пользователю"""
        if user_ip in self.clients:
            try:
                self.server_socket.sendto(message.encode('utf-8'), self.clients[user_ip])
            except:
                self.add_message(f"Не удалось отправить сообщение {user_ip}", "error")
    
    def broadcast_message(self, message):
        """Отправка сообщения всем пользователям"""
        for user_ip, addr in self.clients.items():
            try:
                self.server_socket.sendto(message.encode('utf-8'), addr)
            except:
                pass
    
    def broadcast_to_group(self, group_name, message):
        """Отправка сообщения в группу"""
        if group_name in self.groups:
            for user_ip in self.groups[group_name]:
                if user_ip in self.clients:
                    try:
                        self.server_socket.sendto(message.encode('utf-8'), self.clients[user_ip])
                    except:
                        pass
    
    def setup_gui(self):
        """Настройка графического интерфейса"""
        self.root = tk.Tk()
        self.root.title(f"Локальный мессенджер - {self.host}")
        self.root.geometry("700x600")
        
        # Основной фрейм
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Левая панель - чаты и сообщения
        left_frame = tk.Frame(main_frame)
        left_frame.pack(side='left', fill='both', expand=True)
        
        # Вкладки чатов (реализованные через фреймы)
        self.chat_frames = {}
        self.current_chat = "Общий чат"
        
        # Кнопки для переключения чатов
        chats_frame = tk.LabelFrame(left_frame, text="Чаты")
        chats_frame.pack(fill='x', pady=(0, 5))
        
        # Кнопки основных чатов
        general_btn = tk.Button(chats_frame, text="Общий чат", 
                               command=lambda: self.switch_chat("Общий чат"))
        general_btn.pack(side='left', padx=2)
        
        work_btn = tk.Button(chats_frame, text="Работа", 
                            command=lambda: self.switch_chat("Работа"))
        work_btn.pack(side='left', padx=2)
        
        other_btn = tk.Button(chats_frame, text="Разное", 
                             command=lambda: self.switch_chat("Разное"))
        other_btn.pack(side='left', padx=2)
        
        # Область чата
        chat_frame = tk.LabelFrame(left_frame, text="Сообщения")
        chat_frame.pack(fill='both', expand=True)
        
        self.chat_text = scrolledtext.ScrolledText(
            chat_frame, 
            wrap=tk.WORD, 
            width=50, 
            height=20,
            state='disabled'
        )
        self.chat_text.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Панель ввода сообщения
        input_frame = tk.Frame(left_frame)
        input_frame.pack(fill='x', pady=5)
        
        self.message_entry = tk.Entry(input_frame, width=50)
        self.message_entry.pack(side='left', fill='x', expand=True, padx=(0, 5))
        self.message_entry.bind('<Return>', lambda e: self.send_message())
        
        send_button = tk.Button(input_frame, text="Отправить", command=self.send_message)
        send_button.pack(side='right')
        
        # Правая панель - пользователи и управление
        right_frame = tk.Frame(main_frame)
        right_frame.pack(side='right', fill='y', padx=(10, 0))
        
        # Список пользователей
        users_frame = tk.LabelFrame(right_frame, text="Пользователи онлайн")
        users_frame.pack(fill='x', pady=(0, 10))
        
        self.users_listbox = tk.Listbox(users_frame, height=10, width=20)
        self.users_listbox.pack(fill='both', padx=5, pady=5)
        
        # Кнопки для пользователей
        user_buttons_frame = tk.Frame(users_frame)
        user_buttons_frame.pack(fill='x', pady=5)
        
        private_chat_btn = tk.Button(
            user_buttons_frame, 
            text="Личный чат", 
            command=self.start_private_chat
        )
        private_chat_btn.pack(fill='x', pady=2)
        
        add_to_group_btn = tk.Button(
            user_buttons_frame, 
            text="Добавить в группу", 
            command=self.add_to_group
        )
        add_to_group_btn.pack(fill='x', pady=2)
        
        # Личные чаты
        self.private_chats_frame = tk.LabelFrame(right_frame, text="Личные чаты")
        self.private_chats_frame.pack(fill='x')
        
        self.private_chats_listbox = tk.Listbox(self.private_chats_frame, height=6, width=20)
        self.private_chats_listbox.pack(fill='both', padx=5, pady=5)
        self.private_chats_listbox.bind('<Double-Button-1>', lambda e: self.open_private_chat())
        
        # Кнопки для личных чатов
        private_buttons_frame = tk.Frame(self.private_chats_frame)
        private_buttons_frame.pack(fill='x', pady=5)
        
        open_private_btn = tk.Button(
            private_buttons_frame, 
            text="Открыть чат", 
            command=self.open_private_chat
        )
        open_private_btn.pack(fill='x', pady=2)
        
        remove_private_btn = tk.Button(
            private_buttons_frame, 
            text="Удалить чат", 
            command=self.remove_private_chat
        )
        remove_private_btn.pack(fill='x', pady=2)
        
        # Обновление интерфейса
        self.root.after(1000, self.update_interface)
    
    def switch_chat(self, chat_name):
        """Переключает активный чат"""
        self.current_chat = chat_name
        self.root.title(f"Локальный мессенджер - {self.host} - {chat_name}")
        # В реальном приложении здесь бы обновлялось содержимое чата
    
    def start_private_chat(self):
        """Начинает личный чат с выбранным пользователем"""
        selection = self.users_listbox.curselection()
        if selection:
            user_ip = self.users_listbox.get(selection[0])
            chat_name = f"Лично:{user_ip}"
            
            # Добавляем в список личных чатов если его там нет
            if user_ip not in self.private_chats_listbox.get(0, tk.END):
                self.private_chats_listbox.insert(tk.END, user_ip)
            
            self.switch_chat(chat_name)
            self.add_message(f"Начат личный чат с {user_ip}", "system")
    
    def open_private_chat(self):
        """Открывает выбранный личный чат"""
        selection = self.private_chats_listbox.curselection()
        if selection:
            user_ip = self.private_chats_listbox.get(selection[0])
            self.switch_chat(f"Лично:{user_ip}")
    
    def remove_private_chat(self):
        """Удаляет личный чат из списка"""
        selection = self.private_chats_listbox.curselection()
        if selection:
            self.private_chats_listbox.delete(selection[0])
    
    def add_to_group(self):
        """Добавляет пользователя в группу"""
        selection = self.users_listbox.curselection()
        if selection:
            user_ip = self.users_listbox.get(selection[0])
            
            # Диалог выбора группы
            group_window = tk.Toplevel(self.root)
            group_window.title("Выберите группу")
            group_window.geometry("200x150")
            
            tk.Label(group_window, text="Выберите группу:").pack(pady=10)
            
            group_var = tk.StringVar(value=list(self.groups.keys())[0])
            
            group_frame = tk.Frame(group_window)
            group_frame.pack(pady=5)
            
            for group in self.groups.keys():
                tk.Radiobutton(group_frame, text=group, variable=group_var, value=group).pack(anchor='w')
            
            def confirm_add():
                group = group_var.get()
                self.groups[group].add(user_ip)
                self.add_message(f"Пользователь {user_ip} добавлен в группу '{group}'", "system")
                group_window.destroy()
            
            tk.Button(group_window, text="Добавить", command=confirm_add).pack(pady=5)
    
    def add_message(self, message, msg_type="normal"):
        """Добавляет сообщение в чат"""
        self.chat_text.config(state='normal')
        
        # Цвета для разных типов сообщений
        colors = {
            "system": "blue",
            "error": "red", 
            "private": "purple",
            "my_private": "dark violet",
            "group": "green",
            "my_group": "dark green",
            "my_normal": "black",
            "normal": "gray"
        }
        
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        
        # Добавляем префикс в зависимости от типа чата
        if self.current_chat.startswith("Лично:"):
            prefix = "[Личный] "
        elif self.current_chat in self.groups:
            prefix = f"[{self.current_chat}] "
        else:
            prefix = "[Общий] "
        
        formatted_message = f"{prefix}[{timestamp}] {message}\n"
        
        self.chat_text.insert(tk.END, formatted_message)
        
        # Применяем цвет
        if msg_type in colors:
            start_index = f"{self.chat_text.index(tk.END)} - {len(formatted_message) + 1}c"
            end_index = self.chat_text.index(tk.END)
            self.chat_text.tag_add(msg_type, start_index, end_index)
            self.chat_text.tag_config(msg_type, foreground=colors[msg_type])
        
        self.chat_text.config(state='disabled')
        self.chat_text.see(tk.END)
    
    def get_current_tab(self):
        """Возвращает название текущего чата"""
        return self.current_chat
    
    def update_users_list(self):
        """Обновляет список пользователей"""
        self.users_listbox.delete(0, tk.END)
        for user_ip in self.clients.keys():
            self.users_listbox.insert(tk.END, user_ip)
    
    def update_interface(self):
        """Периодическое обновление интерфейса"""
        self.update_users_list()
        self.root.after(1000, self.update_interface)
    
    def run(self):
        """Запускает приложение"""
        self.root.mainloop()

if __name__ == "__main__":
    # Запуск discovery сервера
    def start_discovery_server():
        discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        discovery_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        discovery_socket.bind(('', 12346))
        
        while True:
            try:
                data, addr = discovery_socket.recvfrom(1024)
                message = data.decode('utf-8')
                if message.startswith("DISCOVERY:"):
                    # Отвечаем на discovery запрос
                    response = f"DISCOVERY:{messenger.host}"
                    discovery_socket.sendto(response.encode('utf-8'), addr)
            except:
                pass
    
    messenger = LocalMessenger()
    
    # Запуск discovery сервера в отдельном потоке
    discovery_thread = threading.Thread(target=start_discovery_server)
    discovery_thread.daemon = True
    discovery_thread.start()

    
    messenger.run()
