import socket
import threading
import tkinter as tk
from tkinter import scrolledtext, messagebox, ttk
import datetime
import time
from googletrans import Translator
import requests
import json

class SimpleMessenger:
    def __init__(self):
        self.host = self.get_local_ip()
        self.port = 8888
        self.clients = {}
        self.running = True
        self.translator = Translator()
        
        print(f"–í–∞—à IP: {self.host}")
        
        self.setup_gui()
        self.start_network()
    
    def get_local_ip(self):
        """–ü–æ–ª—É—á–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π IP"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            try:
                return socket.gethostbyname(socket.gethostname())
            except:
                return "127.0.0.1"
    
    def translate_text(self, text, dest_lang='en'):
        """–ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞"""
        try:
            translated = self.translator.translate(text, dest=dest_lang)
            return translated.text
        except:
            try:
                # –†–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞
                return self.backup_translate(text, dest_lang)
            except:
                return f"[–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞] {text}"
    
    def backup_translate(self, text, dest_lang='en'):
        """–†–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞ —á–µ—Ä–µ–∑ API"""
        # –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        return f"[–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω] {text}"
    
    def start_network(self):
        """–ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ç–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã"""
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        
        try:
            self.udp_socket.bind(('', self.port))
            self.add_message(f"‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {self.port}", "system")
        except Exception as e:
            self.add_message(f"‚ùå –û—à–∏–±–∫–∞: {e}", "error")
            return
        
        threading.Thread(target=self.receive_messages, daemon=True).start()
        threading.Thread(target=self.broadcast_presence, daemon=True).start()
        threading.Thread(target=self.scan_network, daemon=True).start()
    
    def broadcast_presence(self):
        """–†–µ–≥—É–ª—è—Ä–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ broadcast —Å–æ–æ–±—â–µ–Ω–∏–π"""
        while self.running:
            try:
                message = f"HELLO:{self.host}"
                self.udp_socket.sendto(message.encode('utf-8'), ('<broadcast>', self.port))
                time.sleep(3)
            except Exception as e:
                time.sleep(5)
    
    def scan_network(self):
        """–ê–∫—Ç–∏–≤–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∏"""
        base_ip = ".".join(self.host.split('.')[:-1]) + "."
        
        while self.running:
            try:
                for i in range(1, 255):
                    if not self.running:
                        break
                    target_ip = f"{base_ip}{i}"
                    if target_ip != self.host:
                        try:
                            message = f"PING:{self.host}"
                            self.udp_socket.sendto(message.encode('utf-8'), (target_ip, self.port))
                        except:
                            pass
                time.sleep(10)
            except:
                time.sleep(10)
    
    def receive_messages(self):
        """–ü—Ä–∏–µ–º —Å–æ–æ–±—â–µ–Ω–∏–π"""
        while self.running:
            try:
                data, addr = self.udp_socket.recvfrom(1024)
                message = data.decode('utf-8')
                self.handle_message(message, addr[0])
            except:
                pass
    
    def handle_message(self, message, ip):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        if message.startswith("HELLO:"):
            user_ip = message.split(":")[1]
            if user_ip != self.host and user_ip not in self.clients:
                self.clients[user_ip] = ip
                self.update_users_list()
                self.add_message(f"‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω: {user_ip}", "system")
                response = f"HELLO:{self.host}"
                self.udp_socket.sendto(response.encode('utf-8'), (ip, self.port))
        
        elif message.startswith("PING:"):
            user_ip = message.split(":")[1]
            if user_ip != self.host:
                response = f"HELLO:{self.host}"
                self.udp_socket.sendto(response.encode('utf-8'), (ip, self.port))
        
        elif message.startswith("MSG:"):
            parts = message.split(":", 2)
            if len(parts) == 3:
                sender, content = parts[1], parts[2]
                display_msg = f"[{sender}] {content}"
                self.add_message(display_msg, "normal")
                
                # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω
                if self.auto_translate_var.get():
                    translated = self.translate_text(content, self.target_lang.get())
                    self.add_message(f"   ‚Üí {translated}", "translated")
        
        elif message.startswith("PRIVATE:"):
            parts = message.split(":", 3)
            if len(parts) == 4:
                sender, target, content = parts[1], parts[2], parts[3]
                if target == self.host:
                    display_msg = f"[–õ–∏—á–Ω–æ –æ—Ç {sender}] {content}"
                    self.add_message(display_msg, "private")
                    
                    if self.auto_translate_var.get():
                        translated = self.translate_text(content, self.target_lang.get())
                        self.add_message(f"   ‚Üí {translated}", "translated")
    
    def send_message(self, event=None):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        message = self.message_entry.get().strip()
        if not message:
            return
        
        # –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        if self.translate_outgoing_var.get():
            translated_msg = self.translate_text(message, self.target_lang.get())
            display_msg = f"[–Ø] {message} ‚Üí {translated_msg}"
        else:
            display_msg = f"[–Ø] {message}"
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
        for user_ip in self.clients:
            try:
                msg = f"MSG:{self.host}:{message}"
                self.udp_socket.sendto(msg.encode('utf-8'), (user_ip, self.port))
            except:
                pass
        
        self.add_message(display_msg, "my_message")
        self.message_entry.delete(0, tk.END)
    
    def translate_selected_text(self):
        """–ü–µ—Ä–µ–≤–æ–¥ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤ —á–∞—Ç–µ"""
        try:
            selected_text = self.chat_text.get(tk.SEL_FIRST, tk.SEL_LAST)
            if selected_text.strip():
                translated = self.translate_text(selected_text, self.target_lang.get())
                self.add_message(f"üìñ –ü–µ—Ä–µ–≤–æ–¥: {selected_text} ‚Üí {translated}", "system")
        except:
            messagebox.showinfo("–ü–µ—Ä–µ–≤–æ–¥", "–í—ã–¥–µ–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤ —á–∞—Ç–µ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞")
    
    def quick_translate(self):
        """–ë—ã—Å—Ç—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ –∏–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—è"""
        text = self.quick_translate_entry.get().strip()
        if text:
            translated = self.translate_text(text, self.target_lang.get())
            self.add_message(f"üî§ {text} ‚Üí {translated}", "system")
            self.quick_translate_entry.delete(0, tk.END)
    
    def send_private_message(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –ª–∏—á–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        selection = self.users_listbox.curselection()
        if not selection:
            messagebox.showwarning("–í–Ω–∏–º–∞–Ω–∏–µ", "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å–ø–∏—Å–∫–∞")
            return
        
        target_ip = self.users_listbox.get(selection[0])
        message = self.private_entry.get().strip()
        if not message:
            return
        
        try:
            msg = f"PRIVATE:{self.host}:{target_ip}:{message}"
            self.udp_socket.sendto(msg.encode('utf-8'), (target_ip, self.port))
            
            if self.translate_outgoing_var.get():
                translated = self.translate_text(message, self.target_lang.get())
                display_msg = f"[–Ø ‚Üí {target_ip}] {message} ‚Üí {translated}"
            else:
                display_msg = f"[–Ø ‚Üí {target_ip}] {message}"
                
            self.add_message(display_msg, "my_private")
            self.private_entry.delete(0, tk.END)
        except Exception as e:
            self.add_message(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}", "error")
    
    def manual_connect(self):
        """–†—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ IP"""
        ip = self.manual_ip_entry.get().strip()
        if not ip:
            return
        
        if ip == self.host:
            messagebox.showwarning("–í–Ω–∏–º–∞–Ω–∏–µ", "–ù–µ–ª—å–∑—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ–±–µ")
            return
        
        if ip not in self.clients:
            self.clients[ip] = ip
            self.update_users_list()
            self.add_message(f"‚úÖ –†—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: {ip}", "system")
            
            try:
                message = f"HELLO:{self.host}"
                self.udp_socket.sendto(message.encode('utf-8'), (ip, self.port))
            except:
                pass
        
        self.manual_ip_entry.delete(0, tk.END)
    
    def setup_gui(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""
        self.root = tk.Tk()
        self.root.title(f"–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä —Å –ø–µ—Ä–µ–≤–æ–¥–æ–º - {self.host}")
        self.root.geometry("1000x700")
        
        # –û—Å–Ω–æ–≤–Ω–æ–π —Ñ—Ä–µ–π–º
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # –õ–µ–≤–∞—è —á–∞—Å—Ç—å - —á–∞—Ç
        left_frame = tk.Frame(main_frame)
        left_frame.pack(side='left', fill='both', expand=True)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞
        translate_frame = tk.LabelFrame(left_frame, text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞")
        translate_frame.pack(fill='x', pady=(0, 5))
        
        # –Ø–∑—ã–∫ –ø–µ—Ä–µ–≤–æ–¥–∞
        lang_frame = tk.Frame(translate_frame)
        lang_frame.pack(fill='x', pady=2)
        
        tk.Label(lang_frame, text="–Ø–∑—ã–∫ –ø–µ—Ä–µ–≤–æ–¥–∞:").pack(side='left')
        self.target_lang = tk.StringVar(value='en')
        lang_combo = ttk.Combobox(lang_frame, textvariable=self.target_lang, 
                                 values=['en', 'ru', 'es', 'fr', 'de', 'zh', 'ja', 'ko'], width=8)
        lang_combo.pack(side='left', padx=5)
        
        # –ê–≤—Ç–æ–ø–µ—Ä–µ–≤–æ–¥
        self.auto_translate_var = tk.BooleanVar(value=False)
        auto_translate_cb = tk.Checkbutton(translate_frame, text="–ê–≤—Ç–æ–ø–µ—Ä–µ–≤–æ–¥ –≤—Ö–æ–¥—è—â–∏—Ö", 
                                          variable=self.auto_translate_var)
        auto_translate_cb.pack(anchor='w')
        
        self.translate_outgoing_var = tk.BooleanVar(value=False)
        outgoing_cb = tk.Checkbutton(translate_frame, text="–ü–µ—Ä–µ–≤–æ–¥ –∏—Å—Ö–æ–¥—è—â–∏—Ö", 
                                    variable=self.translate_outgoing_var)
        outgoing_cb.pack(anchor='w')
        
        # –ë—ã—Å—Ç—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥
        quick_translate_frame = tk.Frame(translate_frame)
        quick_translate_frame.pack(fill='x', pady=2)
        
        tk.Label(quick_translate_frame, text="–ë—ã—Å—Ç—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥:").pack(side='left')
        self.quick_translate_entry = tk.Entry(quick_translate_frame, width=30)
        self.quick_translate_entry.pack(side='left', padx=5)
        self.quick_translate_entry.bind('<Return>', lambda e: self.quick_translate())
        
        quick_btn = tk.Button(quick_translate_frame, text="–ü–µ—Ä–µ–≤–µ—Å—Ç–∏", command=self.quick_translate)
        quick_btn.pack(side='left')
        
        # –û–±–ª–∞—Å—Ç—å —á–∞—Ç–∞
        chat_frame = tk.LabelFrame(left_frame, text="üí¨ –ß–∞—Ç")
        chat_frame.pack(fill='both', expand=True)
        
        self.chat_text = scrolledtext.ScrolledText(
            chat_frame,
            wrap=tk.WORD,
            state='disabled',
            height=15
        )
        self.chat_text.pack(fill='both', expand=True, padx=5, pady=5)
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
        self.context_menu = tk.Menu(self.chat_text, tearoff=0)
        self.context_menu.add_command(label="–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç", command=self.translate_selected_text)
        self.chat_text.bind("<Button-3>", self.show_context_menu)
        
        # –í–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è
        input_frame = tk.Frame(left_frame)
        input_frame.pack(fill='x', pady=5)
        
        tk.Label(input_frame, text="–°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö:").pack(anchor='w')
        self.message_entry = tk.Entry(input_frame, width=50)
        self.message_entry.pack(fill='x', pady=2)
        self.message_entry.bind('<Return>', self.send_message)
        
        send_btn = tk.Button(input_frame, text="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º", command=self.send_message)
        send_btn.pack(pady=2)
        
        # –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        right_frame = tk.Frame(main_frame)
        right_frame.pack(side='right', fill='y', padx=(10, 0))
        
        # –†—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        manual_frame = tk.LabelFrame(right_frame, text="üîå –†—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ")
        manual_frame.pack(fill='x', pady=(0, 10))
        
        tk.Label(manual_frame, text="IP –∞–¥—Ä–µ—Å:").pack(anchor='w')
        self.manual_ip_entry = tk.Entry(manual_frame)
        self.manual_ip_entry.pack(fill='x', pady=2)
        
        manual_btn = tk.Button(manual_frame, text="–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è", command=self.manual_connect)
        manual_btn.pack(fill='x', pady=2)
        
        # –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        users_frame = tk.LabelFrame(right_frame, text="üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –æ–Ω–ª–∞–π–Ω")
        users_frame.pack(fill='x', pady=(0, 10))
        
        self.users_listbox = tk.Listbox(users_frame, height=8)
        self.users_listbox.pack(fill='both', expand=True, padx=5, pady=5)
        
        # –õ–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        private_frame = tk.LabelFrame(right_frame, text="üîí –õ–∏—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        private_frame.pack(fill='x')
        
        tk.Label(private_frame, text="–°–æ–æ–±—â–µ–Ω–∏–µ:").pack(anchor='w')
        self.private_entry = tk.Entry(private_frame)
        self.private_entry.pack(fill='x', pady=2)
        
        private_btn = tk.Button(private_frame, text="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É", command=self.send_private_message)
        private_btn.pack(fill='x', pady=2)
        
        # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        control_frame = tk.Frame(right_frame)
        control_frame.pack(fill='x', pady=10)
        
        refresh_btn = tk.Button(control_frame, text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫", command=self.force_refresh)
        refresh_btn.pack(fill='x', pady=2)
        
        translate_btn = tk.Button(control_frame, text="üìñ –ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–µ", command=self.translate_selected_text)
        translate_btn.pack(fill='x', pady=2)
        
        clear_btn = tk.Button(control_frame, text="üßπ –û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç", command=self.clear_chat)
        clear_btn.pack(fill='x', pady=2)
        
        self.root.after(1000, self.update_interface)
    
    def show_context_menu(self, event):
        """–ü–æ–∫–∞–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é"""
        try:
            self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.context_menu.grab_release()
    
    def force_refresh(self):
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        self.add_message("üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫...", "system")
        try:
            message = f"HELLO:{self.host}"
            self.udp_socket.sendto(message.encode('utf-8'), ('<broadcast>', self.port))
        except:
            pass
    
    def clear_chat(self):
        """–û—á–∏—Å—Ç–∫–∞ —á–∞—Ç–∞"""
        self.chat_text.config(state='normal')
        self.chat_text.delete(1.0, tk.END)
        self.chat_text.config(state='disabled')
    
    def add_message(self, message, msg_type="normal"):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç"""
        self.chat_text.config(state='normal')
        
        colors = {
            "system": "blue",
            "error": "red",
            "private": "purple", 
            "my_private": "dark violet",
            "my_message": "green",
            "translated": "dark green",
            "normal": "black"
        }
        
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        formatted_message = f"[{timestamp}] {message}\n"
        
        self.chat_text.insert(tk.END, formatted_message)
        
        if msg_type in colors:
            start_index = f"{self.chat_text.index(tk.END)} - {len(formatted_message) + 1}c"
            end_index = self.chat_text.index(tk.END)
            self.chat_text.tag_add(msg_type, start_index, end_index)
            self.chat_text.tag_config(msg_type, foreground=colors[msg_type])
        
        self.chat_text.config(state='disabled')
        self.chat_text.see(tk.END)
    
    def update_users_list(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        self.users_listbox.delete(0, tk.END)
        for user_ip in sorted(self.clients.keys()):
            self.users_listbox.insert(tk.END, user_ip)
    
    def update_interface(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""
        self.update_users_list()
        self.root.after(2000, self.update_interface)
    
    def on_closing(self):
        """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏"""
        self.running = False
        try:
            self.udp_socket.close()
        except:
            pass
        self.root.destroy()
    
    def run(self):
        """–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.root.mainloop()

if __name__ == "__main__":
    app = SimpleMessenger()
    app.run()
